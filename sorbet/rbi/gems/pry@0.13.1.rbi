# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca generate

# typed: true

class BasicObject
  def __binding__; end
end

class Object < ::BasicObject
  include(::Kernel)
  include(::JSON::Ext::Generator::GeneratorMethods::Object)
  include(::PP::ObjectMixin)

  def __binding__; end
  def pry(object = _, hash = _); end
end

class Pry
  extend(::Forwardable)
  extend(::Pry::Forwardable)

  def initialize(options = _); end

  def add_sticky_local(name, &block); end
  def backtrace; end
  def backtrace=(_); end
  def binding_stack; end
  def binding_stack=(_); end
  def color(*args, &block); end
  def color=(*args, &block); end
  def commands(*args, &block); end
  def commands=(*args, &block); end
  def complete(str); end
  def config; end
  def current_binding; end
  def current_context; end
  def custom_completions; end
  def custom_completions=(_); end
  def editor(*args, &block); end
  def editor=(*args, &block); end
  def eval(line, options = _); end
  def eval_string; end
  def eval_string=(_); end
  def evaluate_ruby(code); end
  def exception_handler(*args, &block); end
  def exception_handler=(*args, &block); end
  def exec_hook(name, *args, &block); end
  def exit_value; end
  def extra_sticky_locals(*args, &block); end
  def extra_sticky_locals=(*args, &block); end
  def hooks(*args, &block); end
  def hooks=(*args, &block); end
  def inject_local(name, value, binding); end
  def inject_sticky_locals!; end
  def input(*args, &block); end
  def input=(*args, &block); end
  def input_ring; end
  def last_dir; end
  def last_dir=(_); end
  def last_exception; end
  def last_exception=(exception); end
  def last_file; end
  def last_file=(_); end
  def last_result; end
  def last_result=(_); end
  def last_result_is_exception?; end
  def memory_size; end
  def memory_size=(size); end
  def output; end
  def output=(*args, &block); end
  def output_ring; end
  def pager; end
  def pager=(*args, &block); end
  def pop_prompt; end
  def print(*args, &block); end
  def print=(*args, &block); end
  def process_command(val); end
  def process_command_safely(val); end
  def prompt; end
  def prompt=(new_prompt); end
  def push_binding(object); end
  def push_initial_binding(target = _); end
  def push_prompt(new_prompt); end
  def quiet?; end
  def raise_up(*args); end
  def raise_up!(*args); end
  def raise_up_common(force, *args); end
  def repl(target = _); end
  def reset_eval_string; end
  def run_command(val); end
  def select_prompt; end
  def set_last_result(result, code = _); end
  def should_print?; end
  def show_result(result); end
  def sticky_locals; end
  def suppress_output; end
  def suppress_output=(_); end
  def update_input_history(code); end

  private

  def ensure_correct_encoding!(val); end
  def generate_prompt(prompt_proc, conf); end
  def handle_line(line, options); end
  def prompt_stack; end

  def self.Code(obj); end
  def self.Method(obj); end
  def self.WrappedModule(obj); end
  def self.auto_resize!; end
  def self.binding_for(target); end
  def self.cli; end
  def self.cli=(_); end
  def self.color(*args, &block); end
  def self.color=(*args, &block); end
  def self.commands(*args, &block); end
  def self.commands=(*args, &block); end
  def self.config; end
  def self.config=(_); end
  def self.configure; end
  def self.critical_section; end
  def self.current; end
  def self.current_line; end
  def self.current_line=(_); end
  def self.custom_completions; end
  def self.custom_completions=(_); end
  def self.editor(*args, &block); end
  def self.editor=(*args, &block); end
  def self.eval_path; end
  def self.eval_path=(_); end
  def self.exception_handler(*args, &block); end
  def self.exception_handler=(*args, &block); end
  def self.extra_sticky_locals(*args, &block); end
  def self.extra_sticky_locals=(*args, &block); end
  def self.final_session_setup; end
  def self.history(*args, &block); end
  def self.history=(*args, &block); end
  def self.hooks(*args, &block); end
  def self.hooks=(*args, &block); end
  def self.in_critical_section?; end
  def self.init; end
  def self.initial_session?; end
  def self.initial_session_setup; end
  def self.input(*args, &block); end
  def self.input=(*args, &block); end
  def self.last_internal_error; end
  def self.last_internal_error=(_); end
  def self.line_buffer; end
  def self.line_buffer=(_); end
  def self.load_file_at_toplevel(file); end
  def self.load_file_through_repl(file_name); end
  def self.load_history; end
  def self.load_plugins(*args, &block); end
  def self.load_rc_files; end
  def self.load_requires; end
  def self.load_traps; end
  def self.load_win32console; end
  def self.locate_plugins(*args, &block); end
  def self.main; end
  def self.memory_size(*args, &block); end
  def self.memory_size=(*args, &block); end
  def self.output(*args, &block); end
  def self.output=(*args, &block); end
  def self.pager(*args, &block); end
  def self.pager=(*args, &block); end
  def self.plugins(*args, &block); end
  def self.print(*args, &block); end
  def self.print=(*args, &block); end
  def self.prompt(*args, &block); end
  def self.prompt=(*args, &block); end
  def self.quiet; end
  def self.quiet=(_); end
  def self.rc_files_to_load; end
  def self.real_path_to(file); end
  def self.reset_defaults; end
  def self.run_command(command_string, options = _); end
  def self.start(target = _, options = _); end
  def self.start_with_pry_byebug(target = _, options = _); end
  def self.start_without_pry_byebug(target = _, options = _); end
  def self.toplevel_binding; end
  def self.toplevel_binding=(_); end
  def self.view_clip(obj, options = _); end
end

Pry::BINDING_METHOD_IMPL = T.let(T.unsafe(nil), Array)

class Pry::BasicObject < ::BasicObject
  include(::Kernel)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::ENV = T.let(T.unsafe(nil), Object)

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::BlockCommand < ::Pry::Command
  def call(*args); end
  def help; end
end

class Pry::CLI
  def self.add_option_processor(&block); end
  def self.add_options(&block); end
  def self.add_plugin_options; end
  def self.input_args; end
  def self.input_args=(_); end
  def self.option_processors; end
  def self.option_processors=(_); end
  def self.options; end
  def self.options=(_); end
  def self.parse_options(args = _); end
  def self.reset; end
  def self.start(opts); end
end

class Pry::CLI::NoOptionsError < ::StandardError
end

class Pry::ClassCommand < ::Pry::Command
  def args; end
  def args=(_); end
  def call(*args); end
  def complete(search); end
  def help; end
  def options(opt); end
  def opts; end
  def opts=(_); end
  def process; end
  def setup; end
  def slop; end
  def subcommands(cmd); end

  def self.doc; end
  def self.file; end
  def self.inherited(klass); end
  def self.line; end
  def self.source; end
  def self.source_file; end
  def self.source_line; end
  def self.source_location; end
end

class Pry::Code
  extend(::MethodSource::CodeHelpers)

  def initialize(lines = _, start_line = _, code_type = _); end

  def <<(line); end
  def ==(other); end
  def after(lineno, lines = _); end
  def around(lineno, lines = _); end
  def before(lineno, lines = _); end
  def between(start_line, end_line = _); end
  def code_type; end
  def code_type=(_); end
  def comment_describing(line_number); end
  def expression_at(line_number, consume = _); end
  def grep(pattern); end
  def highlighted; end
  def length; end
  def max_lineno_width; end
  def method_missing(method_name, *args, &block); end
  def nesting_at(line_number); end
  def print_to_output(output, color = _); end
  def push(line); end
  def raw; end
  def reject(&block); end
  def select(&block); end
  def take_lines(start_line, num_lines); end
  def to_s; end
  def with_indentation(spaces = _); end
  def with_line_numbers(y_n = _); end
  def with_marker(lineno = _); end

  protected

  def alter(&block); end

  private

  def respond_to_missing?(method_name, include_private = _); end

  def self.from_file(filename, code_type = _); end
  def self.from_method(meth, start_line = _); end
  def self.from_module(mod, candidate_rank = _, start_line = _); end
end

class Pry::Code::CodeRange
  def initialize(start_line, end_line = _); end

  def indices_range(lines); end

  private

  def end_line; end
  def find_end_index(lines); end
  def find_start_index(lines); end
  def force_set_end_line; end
  def indices(lines); end
  def set_end_line_from_range; end
  def start_line; end
end

class Pry::Code::LOC
  def initialize(line, lineno); end

  def ==(other); end
  def add_line_number(max_width = _, color = _); end
  def add_marker(marker_lineno); end
  def colorize(code_type); end
  def dup; end
  def handle_multiline_entries_from_edit_command(line, max_width); end
  def indent(distance); end
  def line; end
  def lineno; end
  def tuple; end
end

class Pry::CodeFile
  def initialize(filename, code_type = _); end

  def code; end
  def code_type; end

  private

  def abs_path; end
  def code_path; end
  def from_load_path; end
  def from_pry_init_pwd; end
  def from_pwd; end
  def readable?(path); end
  def type_from_filename(filename, default = _); end
end

Pry::CodeFile::DEFAULT_EXT = T.let(T.unsafe(nil), String)

Pry::CodeFile::EXTENSIONS = T.let(T.unsafe(nil), Hash)

Pry::CodeFile::FILES = T.let(T.unsafe(nil), Hash)

Pry::CodeFile::INITIAL_PWD = T.let(T.unsafe(nil), String)

class Pry::CodeObject
  include(::Pry::Helpers::OptionsHelpers)
  include(::Pry::Helpers::CommandHelpers)

  def initialize(str, pry_instance, options = _); end

  def command_lookup; end
  def default_lookup; end
  def empty_lookup; end
  def method_or_class_lookup; end
  def pry_instance; end
  def pry_instance=(_); end
  def str; end
  def str=(_); end
  def super_level; end
  def super_level=(_); end
  def target; end
  def target=(_); end

  private

  def looks_like_an_instance_method?(str); end
  def lookup_super(obj, super_level); end
  def safe_to_evaluate?(str); end
  def sourcable_object?(obj); end
  def target_self; end

  def self.lookup(str, pry_instance, options = _); end
end

module Pry::CodeObject::Helpers
  def c_method?; end
  def c_module?; end
  def command?; end
  def module_with_yard_docs?; end
  def real_method_object?; end
end

class Pry::ColorPrinter < ::PP
  def pp(object); end
  def text(str, max_width = _); end

  private

  def highlight_object_literal(object_literal); end
  def inspect_object(object); end

  def self.default(_output, value, pry_instance); end
  def self.pp(obj, output = _, max_width = _); end
end

class Pry::Command
  include(::Pry::Helpers::BaseHelpers)
  include(::Pry::Helpers::OptionsHelpers)
  include(::Pry::Helpers::CommandHelpers)
  include(::Pry::Helpers::Text)
  extend(::Pry::Helpers::DocumentationHelpers)
  extend(::Pry::CodeObject::Helpers)

  def initialize(context = _); end

  def _pry_; end
  def _pry_=(_); end
  def arg_string; end
  def arg_string=(_); end
  def block; end
  def captures; end
  def captures=(_); end
  def check_for_command_collision(command_match, arg_string); end
  def command_block; end
  def command_block=(_); end
  def command_name; end
  def command_options; end
  def command_set; end
  def command_set=(_); end
  def commands; end
  def complete(_search); end
  def context; end
  def context=(_); end
  def description; end
  def eval_string; end
  def eval_string=(_); end
  def hooks; end
  def hooks=(_); end
  def interpolate_string(str); end
  def match; end
  def name; end
  def output; end
  def output=(_); end
  def process_line(line); end
  def pry_instance; end
  def pry_instance=(_); end
  def run(command_string, *args); end
  def source; end
  def state; end
  def target; end
  def target=(_); end
  def target_self; end
  def tokenize(val); end
  def void; end

  private

  def after_hooks; end
  def before_hooks; end
  def call_safely(*args); end
  def call_with_hooks(*args); end
  def find_hooks(event); end
  def normalize_method_args(method, args); end
  def pass_block(arg_string); end
  def use_unpatched_symbol; end

  def self.banner(arg = _); end
  def self.block; end
  def self.block=(_); end
  def self.command_name; end
  def self.command_options(arg = _); end
  def self.command_options=(_); end
  def self.command_regex; end
  def self.convert_to_regex(obj); end
  def self.default_options(match); end
  def self.description(arg = _); end
  def self.description=(_); end
  def self.doc; end
  def self.file; end
  def self.group(name = _); end
  def self.inspect; end
  def self.line; end
  def self.match(arg = _); end
  def self.match=(_); end
  def self.match_score(val); end
  def self.matches?(val); end
  def self.name; end
  def self.options(arg = _); end
  def self.options=(_); end
  def self.source; end
  def self.source_file; end
  def self.source_line; end
  def self.state; end
  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::Command::AmendLine < ::Pry::ClassCommand
  def process; end

  private

  def amend_input; end
  def delete_from_array(array, range); end
  def insert_into_array(array, range); end
  def line_count; end
  def line_range; end
  def replace_in_array(array, range); end
  def start_and_end_line_number; end
  def zero_indexed_range_from_one_indexed_numbers(start_line_number, end_line_number); end
end

class Pry::Command::Bang < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::BangPry < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::Cat < ::Pry::ClassCommand
  def complete(search); end
  def load_path_completions; end
  def options(opt); end
  def process; end
end

class Pry::Command::Cat::AbstractFormatter
  include(::Pry::Helpers::OptionsHelpers)
  include(::Pry::Helpers::CommandHelpers)
  include(::Pry::Helpers::BaseHelpers)


  private

  def between_lines; end
  def code_type; end
  def decorate(content); end
  def use_line_numbers?; end
end

class Pry::Command::Cat::ExceptionFormatter < ::Pry::Command::Cat::AbstractFormatter
  include(::Pry::Helpers::Text)

  def initialize(exception, pry_instance, opts); end

  def ex; end
  def format; end
  def opts; end
  def pry_instance; end

  private

  def backtrace_file; end
  def backtrace_level; end
  def backtrace_line; end
  def check_for_errors; end
  def code_window_size; end
  def header; end
  def increment_backtrace_level; end
  def start_and_end_line_for_code_window; end
end

class Pry::Command::Cat::FileFormatter < ::Pry::Command::Cat::AbstractFormatter
  def initialize(file_with_embedded_line, pry_instance, opts); end

  def file_and_line; end
  def file_with_embedded_line; end
  def format; end
  def opts; end
  def pry_instance; end

  private

  def code_type; end
  def code_window_size; end
  def decorate(content); end
  def detect_code_type_from_file(file_name); end
  def file_name; end
  def line_number; end
end

class Pry::Command::Cat::InputExpressionFormatter < ::Pry::Command::Cat::AbstractFormatter
  def initialize(input_expressions, opts); end

  def format; end
  def input_expressions; end
  def input_expressions=(_); end
  def opts; end
  def opts=(_); end

  private

  def normalized_expression_range; end
  def numbered_input_items; end
  def selected_input_items; end
end

class Pry::Command::Cd < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::ChangeInspector < ::Pry::ClassCommand
  def process(inspector); end

  private

  def inspector_map; end
end

class Pry::Command::ChangePrompt < ::Pry::ClassCommand
  def options(opt); end
  def process(prompt); end

  private

  def change_prompt(prompt); end
  def list_prompts; end
end

class Pry::Command::ClearScreen < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::CodeCollector
  include(::Pry::Helpers::OptionsHelpers)
  include(::Pry::Helpers::CommandHelpers)

  def initialize(args, opts, pry_instance); end

  def args; end
  def code_object; end
  def content; end
  def file; end
  def file=(_); end
  def line_range; end
  def obj_name; end
  def opts; end
  def pry_input_content; end
  def pry_instance; end
  def pry_output_content; end
  def restrict_to_lines(content, range); end

  private

  def bad_option_combination?; end
  def code_object_doc; end
  def code_object_source_or_file; end
  def convert_to_range(range); end
  def could_not_locate(name); end
  def file_content; end
  def pry_array_content_as_string(array, ranges); end

  def self.inject_options(opt); end
  def self.input_expression_ranges; end
  def self.input_expression_ranges=(_); end
  def self.output_result_ranges; end
  def self.output_result_ranges=(_); end
end

class Pry::Command::DisablePry < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::Edit < ::Pry::ClassCommand
  def apply_runtime_patch; end
  def bad_option_combination?; end
  def code_object; end
  def ensure_file_name_is_valid(file_name); end
  def file_and_line; end
  def file_and_line_for_current_exception; end
  def file_based_exception?; end
  def file_edit; end
  def filename_argument; end
  def initial_temp_file_content; end
  def input_expression; end
  def never_reload?; end
  def options(opt); end
  def patch_exception?; end
  def previously_patched?(code_object); end
  def probably_a_file?(str); end
  def process; end
  def pry_method?(code_object); end
  def reload?(file_name = _); end
  def reloadable?; end
  def repl_edit; end
  def repl_edit?; end
  def runtime_patch?; end
end

class Pry::Command::Edit::ExceptionPatcher
  def initialize(pry_instance, state, exception_file_and_line); end

  def file_and_line; end
  def file_and_line=(_); end
  def perform_patch; end
  def pry_instance; end
  def pry_instance=(_); end
  def state; end
  def state=(_); end
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end
  def self.from_code_object(code_object, filename_argument); end
  def self.from_exception(exception, backtrace_level); end
  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Exit < ::Pry::ClassCommand
  def process; end
  def process_pop_and_return; end
end

class Pry::Command::ExitAll < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::ExitProgram < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::FindMethod < ::Pry::ClassCommand
  extend(::Pry::Helpers::BaseHelpers)

  def options(opt); end
  def process; end

  private

  def additional_info(header, method); end
  def content_search(namespace); end
  def matched_method_lines(header, method); end
  def name_search(namespace); end
  def pattern; end
  def print_matches(matches); end
  def print_matches_for_class(klass, grouped); end
  def recurse_namespace(klass, done = _, &block); end
  def search_all_methods(namespace); end
  def search_class; end
  def show_search_results(matches); end
end

class Pry::Command::FixIndent < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::Help < ::Pry::ClassCommand
  def command_groups; end
  def display_command(command); end
  def display_filtered_commands(search); end
  def display_filtered_search_results(search); end
  def display_index(groups); end
  def display_search(search); end
  def group_sort_key(group_name); end
  def help_text_for_commands(name, commands); end
  def normalize(key); end
  def process; end
  def search_hash(search, hash); end
  def sorted_commands(commands); end
  def sorted_group_names(groups); end
  def visible_commands; end
end

class Pry::Command::Hist < ::Pry::ClassCommand
  def options(opt); end
  def process; end

  private

  def check_for_juxtaposed_replay(replay_sequence); end
  def find_history; end
  def process_clear; end
  def process_display; end
  def process_replay; end
  def process_save; end
end

class Pry::Command::ImportSet < ::Pry::ClassCommand
  def process(_command_set_name); end
end

class Pry::Command::JumpTo < ::Pry::ClassCommand
  def process(break_level); end
end

class Pry::Command::ListInspectors < ::Pry::ClassCommand
  def process; end

  private

  def inspector_map; end
  def selected_inspector?(inspector); end
  def selected_text; end
end

class Pry::Command::Ls < ::Pry::ClassCommand
  def no_user_opts?; end
  def options(opt); end
  def process; end

  private

  def error_list; end
  def raise_errors_if_arguments_are_weird; end
end

class Pry::Command::Ls::Constants < ::Pry::Command::Ls::Formatter
  include(::Pry::Command::Ls::Interrogatable)

  def initialize(interrogatee, no_user_opts, opts, pry_instance); end

  def correct_opts?; end
  def output_self; end

  private

  def format(mod, constants); end
  def show_deprecated_constants?; end
end

Pry::Command::Ls::Constants::DEPRECATED_CONSTANTS = T.let(T.unsafe(nil), Array)

Pry::Command::Ls::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Pry::Command::Ls::Formatter
  def initialize(pry_instance); end

  def grep=(_); end
  def pry_instance; end
  def write_out; end

  private

  def color(type, str); end
  def correct_opts?; end
  def format_value(value); end
  def grep; end
  def output_section(heading, body); end
  def output_self; end
end

class Pry::Command::Ls::Globals < ::Pry::Command::Ls::Formatter
  def initialize(opts, pry_instance); end

  def output_self; end

  private

  def format(globals); end
end

Pry::Command::Ls::Globals::BUILTIN_GLOBALS = T.let(T.unsafe(nil), Array)

Pry::Command::Ls::Globals::PSEUDO_GLOBALS = T.let(T.unsafe(nil), Array)

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp; end
end

class Pry::Command::Ls::InstanceVars < ::Pry::Command::Ls::Formatter
  include(::Pry::Command::Ls::Interrogatable)

  def initialize(interrogatee, no_user_opts, opts, pry_instance); end

  def correct_opts?; end
  def output_self; end

  private

  def format(type, vars); end
end

module Pry::Command::Ls::Interrogatable

  private

  def interrogatee_mod; end
  def interrogating_a_module?; end
end

module Pry::Command::Ls::JRubyHacks

  private

  def rubbishness(name); end
  def trim_jruby_aliases(methods); end
end

class Pry::Command::Ls::LocalNames < ::Pry::Command::Ls::Formatter
  def initialize(no_user_opts, args, pry_instance); end

  def correct_opts?; end
  def output_self; end

  private

  def format(locals); end
end

class Pry::Command::Ls::LocalVars < ::Pry::Command::Ls::Formatter
  def initialize(opts, pry_instance); end

  def output_self; end

  private

  def colorized_assignment_style(lhs, rhs, desired_width = _); end
  def format(name_value_pairs); end
end

class Pry::Command::Ls::LsEntity
  def initialize(opts); end

  def entities_table; end
  def pry_instance; end

  private

  def constants; end
  def entities; end
  def globals; end
  def grep(entity); end
  def instance_vars; end
  def local_names; end
  def local_vars; end
  def methods; end
  def self_methods; end
end

class Pry::Command::Ls::Methods < ::Pry::Command::Ls::Formatter
  include(::Pry::Command::Ls::Interrogatable)
  include(::Pry::Command::Ls::JRubyHacks)
  include(::Pry::Command::Ls::MethodsHelper)

  def initialize(interrogatee, no_user_opts, opts, pry_instance); end

  def output_self; end

  private

  def below_ceiling; end
  def correct_opts?; end
end

module Pry::Command::Ls::MethodsHelper
  include(::Pry::Command::Ls::JRubyHacks)


  private

  def all_methods(instance_methods = _); end
  def format(methods); end
  def resolution_order; end
end

class Pry::Command::Ls::SelfMethods < ::Pry::Command::Ls::Formatter
  include(::Pry::Command::Ls::Interrogatable)
  include(::Pry::Command::Ls::JRubyHacks)
  include(::Pry::Command::Ls::MethodsHelper)

  def initialize(interrogatee, no_user_opts, opts, pry_instance); end

  def output_self; end

  private

  def correct_opts?; end
end

class Pry::Command::Nesting < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::Play < ::Pry::ClassCommand
  def code_object; end
  def content; end
  def content_after_options; end
  def content_at_expression; end
  def default_file; end
  def file_content; end
  def options(opt); end
  def perform_play; end
  def process; end
  def should_use_default_file?; end
  def show_input; end
end

class Pry::Command::PryBacktrace < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::RaiseUp < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::ReloadCode < ::Pry::ClassCommand
  def process; end

  private

  def check_for_reloadability(code_object, identifier); end
  def current_file; end
  def reload_current_file; end
  def reload_object(identifier); end
end

class Pry::Command::Reset < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::Ri < ::Pry::ClassCommand
  def process(spec); end
end

class Pry::Command::SaveFile < ::Pry::ClassCommand
  def display_content; end
  def file_name; end
  def mode; end
  def options(opt); end
  def process; end
  def save_file; end
end

class Pry::Command::ShellCommand < ::Pry::ClassCommand
  def process(cmd); end

  private

  def cd_path_env; end
  def cd_path_exists?; end
  def parse_destination(dest); end
  def path_from_cd_path(dest); end
  def process_cd(dest); end
  def special_case_path?(dest); end
end

class Pry::Command::ShellMode < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::ShowDoc < ::Pry::Command::ShowInfo
  include(::Pry::Helpers::DocumentationHelpers)

  def content_for(code_object); end
  def docs_for(code_object); end
  def header_options; end
  def process; end
  def render_doc_markup_for(code_object); end
  def start_line_for(code_object); end
end

class Pry::Command::ShowInfo < ::Pry::ClassCommand
  extend(::Pry::Helpers::BaseHelpers)

  def initialize(*_); end

  def code_object_header(code_object, line_num); end
  def code_object_with_accessible_source(code_object); end
  def complete(input); end
  def content_and_header_for_code_object(code_object); end
  def content_and_headers_for_all_module_candidates(mod); end
  def file_and_line_for(code_object); end
  def header(code_object); end
  def header_options; end
  def method_header(code_object, line_num); end
  def method_sections(code_object); end
  def module_header(code_object, line_num); end
  def no_definition_message; end
  def obj_name; end
  def options(opt); end
  def process; end
  def show_all_modules?(code_object); end
  def start_line_for(code_object); end
  def use_line_numbers?; end
  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInput < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::ShowSource < ::Pry::Command::ShowInfo
  include(::Pry::Helpers::DocumentationHelpers)

  def content_for(code_object); end
  def docs_for(code_object); end
  def header_options; end
  def options(opt); end
  def process; end
  def render_doc_markup_for(code_object); end
  def start_line_for(code_object); end
end

class Pry::Command::Stat < ::Pry::ClassCommand
  def options(opt); end
  def process; end
end

class Pry::Command::SwitchTo < ::Pry::ClassCommand
  def process(selection); end
end

class Pry::Command::ToggleColor < ::Pry::ClassCommand
  def color_toggle; end
  def process; end
end

Pry::Command::VOID_VALUE = T.let(T.unsafe(nil), Object)

class Pry::Command::Version < ::Pry::ClassCommand
  def process; end
end

class Pry::Command::WatchExpression < ::Pry::ClassCommand
  def options(opt); end
  def process; end

  private

  def add_expression(_arguments); end
  def add_hook; end
  def delete(index); end
  def eval_and_print_changed(output); end
  def expressions; end
  def list; end
end

class Pry::Command::WatchExpression::Expression
  def initialize(pry_instance, target, source); end

  def changed?; end
  def eval!; end
  def previous_value; end
  def pry_instance; end
  def source; end
  def target; end
  def to_s; end
  def value; end

  private

  def target_eval(target, source); end
end

class Pry::Command::Whereami < ::Pry::ClassCommand
  def initialize(*_); end

  def bad_option_combination?; end
  def code; end
  def code?; end
  def location; end
  def options(opt); end
  def process; end
  def setup; end

  private

  def class_code; end
  def code_window; end
  def default_code; end
  def expand_path(filename); end
  def handle_internal_binding; end
  def marker; end
  def method_code; end
  def nothing_to_do?; end
  def small_method?; end
  def target_class; end
  def top_level?; end
  def use_line_numbers?; end
  def valid_method?; end
  def window_size; end

  def self.method_size_cutoff; end
  def self.method_size_cutoff=(_); end
end

class Pry::Command::Wtf < ::Pry::ClassCommand
  def options(opt); end
  def process; end

  private

  def format_backtrace(backtrace); end
  def format_header(title, exception); end
  def read_line(file, line); end
  def trim_backtrace(backtrace); end
  def unwind_exceptions; end
end

Pry::Command::Wtf::RUBY_FRAME_PATTERN = T.let(T.unsafe(nil), Regexp)

class Pry::CommandError < ::StandardError
end

class Pry::CommandSet
  include(::Enumerable)
  include(::Pry::Helpers::BaseHelpers)

  def initialize(*imported_sets, &block); end

  def [](pattern); end
  def []=(pattern, command); end
  def add_command(command); end
  def alias_command(match, action, options = _); end
  def block_command(match, description = _, options = _, &block); end
  def command(match, description = _, options = _, &block); end
  def complete(search, context = _); end
  def create_command(match, description = _, options = _, &block); end
  def delete(*searches); end
  def desc(search, description = _); end
  def each(&block); end
  def find_command(pattern); end
  def find_command_by_match_or_listing(match_or_listing); end
  def find_command_for_help(search); end
  def helper_module; end
  def import(*sets); end
  def import_from(set, *matches); end
  def keys; end
  def list_commands; end
  def process_line(val, context = _); end
  def rename_command(new_match, search, options = _); end
  def to_h; end
  def to_hash; end
  def valid_command?(val); end

  private

  def helpers(&block); end
end

class Pry::CommandState
  def initialize; end

  def reset(command_name); end
  def state_for(command_name); end

  def self.default; end
end

Pry::Commands = T.let(T.unsafe(nil), Pry::CommandSet)

class Pry::Config
  extend(::Pry::Config::Attributable)

  def initialize; end

  def [](attr); end
  def []=(attr, value); end
  def auto_indent; end
  def auto_indent=(_); end
  def collision_warning; end
  def collision_warning=(_); end
  def color; end
  def color=(_); end
  def command_completions; end
  def command_completions=(_); end
  def command_prefix; end
  def command_prefix=(_); end
  def commands; end
  def commands=(_); end
  def completer; end
  def completer=(_); end
  def control_d_handler; end
  def control_d_handler=(value); end
  def correct_indent; end
  def correct_indent=(_); end
  def default_window_size; end
  def default_window_size=(_); end
  def disable_auto_reload; end
  def disable_auto_reload=(_); end
  def editor; end
  def editor=(_); end
  def exception_handler; end
  def exception_handler=(_); end
  def exception_whitelist; end
  def exception_whitelist=(_); end
  def exec_string; end
  def exec_string=(_); end
  def extra_sticky_locals; end
  def extra_sticky_locals=(_); end
  def file_completions; end
  def file_completions=(_); end
  def history; end
  def history=(_); end
  def history_file; end
  def history_file=(_); end
  def history_ignorelist; end
  def history_ignorelist=(_); end
  def history_load; end
  def history_load=(_); end
  def history_save; end
  def history_save=(_); end
  def hooks; end
  def hooks=(_); end
  def input; end
  def input=(_); end
  def ls; end
  def ls=(_); end
  def memory_size; end
  def memory_size=(_); end
  def merge(config_hash); end
  def merge!(config_hash); end
  def method_missing(method_name, *args, &_block); end
  def output; end
  def output=(_); end
  def output_prefix; end
  def output_prefix=(_); end
  def pager; end
  def pager=(_); end
  def print; end
  def print=(_); end
  def prompt; end
  def prompt=(_); end
  def prompt_name; end
  def prompt_name=(_); end
  def prompt_safe_contexts; end
  def prompt_safe_contexts=(_); end
  def quiet; end
  def quiet=(_); end
  def rc_file; end
  def rc_file=(_); end
  def requires; end
  def requires=(_); end
  def should_load_local_rc; end
  def should_load_local_rc=(_); end
  def should_load_plugins; end
  def should_load_plugins=(_); end
  def should_load_rc; end
  def should_load_rc=(_); end
  def should_load_requires; end
  def should_load_requires=(_); end
  def should_trap_interrupts; end
  def should_trap_interrupts=(_); end
  def system; end
  def system=(_); end
  def unrescued_exceptions; end
  def unrescued_exceptions=(_); end
  def windows_console_warning; end
  def windows_console_warning=(_); end

  private

  def default_rc_file; end
  def initialize_dup(other); end
  def lazy_readline; end
  def respond_to_missing?(method_name, include_all = _); end
end

module Pry::Config::Attributable
  def attribute(attr_name); end
end

class Pry::Config::LazyValue
  def initialize(&block); end

  def call; end
end

class Pry::Config::MemoizedValue
  def initialize(&block); end

  def call; end
end

class Pry::Config::Value
  def initialize(value); end

  def call; end
end

module Pry::ControlDHandler
  def self.default(pry_instance); end
end

Pry::EMPTY_COMPLETIONS = T.let(T.unsafe(nil), Array)

class Pry::Editor
  include(::Pry::Helpers::OptionsHelpers)
  include(::Pry::Helpers::CommandHelpers)

  def initialize(pry_instance); end

  def build_editor_invocation_string(file, line, blocking); end
  def edit_tempfile_with_content(initial_content, line = _); end
  def invoke_editor(file, line, blocking = _); end
  def pry_instance; end

  private

  def blocking_flag_for_editor(blocking); end
  def editor_name; end
  def open_editor(editor_invocation); end
  def open_editor_on_jruby(editor_invocation); end
  def start_line_syntax_for_editor(file_name, line_number); end

  def self.default; end
end

module Pry::Env
  def self.[](key); end
end

module Pry::ExceptionHandler
  def self.handle_exception(output, exception, _pry_instance); end
end

module Pry::Forwardable
  include(::Forwardable)

  def def_private_delegators(target, *private_delegates); end
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

Pry::HAS_SAFE_LEVEL = T.let(T.unsafe(nil), TrueClass)

module Pry::Helpers
  def self.tablify(things, line_length, pry_instance = _); end
  def self.tablify_or_one_line(heading, things, pry_instance = _); end
  def self.tablify_to_screen_width(things, options, pry_instance = _); end
end

module Pry::Helpers::BaseHelpers
  extend(::Pry::Helpers::BaseHelpers)

  def colorize_code(code); end
  def find_command(name, set = _); end
  def heading(text); end
  def highlight(string, regexp, highlight_color = _); end
  def not_a_real_file?(file); end
  def safe_send(obj, method, *args, &block); end
  def silence_warnings; end
  def stagger_output(text, _out = _); end
  def use_ansi_codes?; end
end

module Pry::Helpers::CommandHelpers
  include(::Pry::Helpers::OptionsHelpers)
  extend(::Pry::Helpers::OptionsHelpers)
  extend(::Pry::Helpers::CommandHelpers)

  def absolute_index_number(line_number, array_length); end
  def absolute_index_range(range_or_number, array_length); end
  def get_method_or_raise(method_name, context, opts = _); end
  def internal_binding?(context); end
  def one_index_number(line_number); end
  def one_index_range(range); end
  def one_index_range_or_number(range_or_number); end
  def restrict_to_lines(content, lines); end
  def set_file_and_dir_locals(file_name, pry = _, ctx = _); end
  def temp_file(ext = _); end
  def unindent(dirty_text, left_padding = _); end
end

module Pry::Helpers::DocumentationHelpers

  private

  def get_comment_content(comment); end
  def process_comment_markup(comment); end
  def process_rdoc(comment); end
  def process_yardoc(comment); end
  def process_yardoc_tag(comment, tag); end
  def strip_comments_from_c_code(code); end
  def strip_leading_whitespace(text); end

  def self.get_comment_content(comment); end
  def self.process_comment_markup(comment); end
  def self.process_rdoc(comment); end
  def self.process_yardoc(comment); end
  def self.process_yardoc_tag(comment, tag); end
  def self.strip_comments_from_c_code(code); end
  def self.strip_leading_whitespace(text); end
end

Pry::Helpers::DocumentationHelpers::YARD_TAGS = T.let(T.unsafe(nil), Array)

module Pry::Helpers::OptionsHelpers

  private

  def method_object; end
  def method_options(opt); end

  def self.method_object; end
  def self.method_options(opt); end
end

module Pry::Helpers::Platform
  def self.jruby?; end
  def self.jruby_19?; end
  def self.linux?; end
  def self.mac_osx?; end
  def self.mri?; end
  def self.mri_19?; end
  def self.mri_2?; end
  def self.windows?; end
  def self.windows_ansi?; end
end

class Pry::Helpers::Table
  def initialize(items, args, pry_instance = _); end

  def ==(other); end
  def column_count; end
  def column_count=(count); end
  def columns; end
  def fits_on_line?(line_length); end
  def items; end
  def items=(items); end
  def rows_to_s(style = _); end
  def to_a; end
  def to_s; end

  private

  def _max_width(things); end
  def _rebuild_colorless_cache; end
  def _recall_color_for(thing); end
  def _recolumn; end
end

module Pry::Helpers::Text
  extend(::Pry::Helpers::Text)

  def black(text); end
  def black_on_black(text); end
  def black_on_blue(text); end
  def black_on_cyan(text); end
  def black_on_green(text); end
  def black_on_magenta(text); end
  def black_on_purple(text); end
  def black_on_red(text); end
  def black_on_white(text); end
  def black_on_yellow(text); end
  def blue(text); end
  def blue_on_black(text); end
  def blue_on_blue(text); end
  def blue_on_cyan(text); end
  def blue_on_green(text); end
  def blue_on_magenta(text); end
  def blue_on_purple(text); end
  def blue_on_red(text); end
  def blue_on_white(text); end
  def blue_on_yellow(text); end
  def bold(text); end
  def bright_black(text); end
  def bright_black_on_black(text); end
  def bright_black_on_blue(text); end
  def bright_black_on_cyan(text); end
  def bright_black_on_green(text); end
  def bright_black_on_magenta(text); end
  def bright_black_on_purple(text); end
  def bright_black_on_red(text); end
  def bright_black_on_white(text); end
  def bright_black_on_yellow(text); end
  def bright_blue(text); end
  def bright_blue_on_black(text); end
  def bright_blue_on_blue(text); end
  def bright_blue_on_cyan(text); end
  def bright_blue_on_green(text); end
  def bright_blue_on_magenta(text); end
  def bright_blue_on_purple(text); end
  def bright_blue_on_red(text); end
  def bright_blue_on_white(text); end
  def bright_blue_on_yellow(text); end
  def bright_cyan(text); end
  def bright_cyan_on_black(text); end
  def bright_cyan_on_blue(text); end
  def bright_cyan_on_cyan(text); end
  def bright_cyan_on_green(text); end
  def bright_cyan_on_magenta(text); end
  def bright_cyan_on_purple(text); end
  def bright_cyan_on_red(text); end
  def bright_cyan_on_white(text); end
  def bright_cyan_on_yellow(text); end
  def bright_green(text); end
  def bright_green_on_black(text); end
  def bright_green_on_blue(text); end
  def bright_green_on_cyan(text); end
  def bright_green_on_green(text); end
  def bright_green_on_magenta(text); end
  def bright_green_on_purple(text); end
  def bright_green_on_red(text); end
  def bright_green_on_white(text); end
  def bright_green_on_yellow(text); end
  def bright_magenta(text); end
  def bright_magenta_on_black(text); end
  def bright_magenta_on_blue(text); end
  def bright_magenta_on_cyan(text); end
  def bright_magenta_on_green(text); end
  def bright_magenta_on_magenta(text); end
  def bright_magenta_on_purple(text); end
  def bright_magenta_on_red(text); end
  def bright_magenta_on_white(text); end
  def bright_magenta_on_yellow(text); end
  def bright_purple(text); end
  def bright_purple_on_black(text); end
  def bright_purple_on_blue(text); end
  def bright_purple_on_cyan(text); end
  def bright_purple_on_green(text); end
  def bright_purple_on_magenta(text); end
  def bright_purple_on_purple(text); end
  def bright_purple_on_red(text); end
  def bright_purple_on_white(text); end
  def bright_purple_on_yellow(text); end
  def bright_red(text); end
  def bright_red_on_black(text); end
  def bright_red_on_blue(text); end
  def bright_red_on_cyan(text); end
  def bright_red_on_green(text); end
  def bright_red_on_magenta(text); end
  def bright_red_on_purple(text); end
  def bright_red_on_red(text); end
  def bright_red_on_white(text); end
  def bright_red_on_yellow(text); end
  def bright_white(text); end
  def bright_white_on_black(text); end
  def bright_white_on_blue(text); end
  def bright_white_on_cyan(text); end
  def bright_white_on_green(text); end
  def bright_white_on_magenta(text); end
  def bright_white_on_purple(text); end
  def bright_white_on_red(text); end
  def bright_white_on_white(text); end
  def bright_white_on_yellow(text); end
  def bright_yellow(text); end
  def bright_yellow_on_black(text); end
  def bright_yellow_on_blue(text); end
  def bright_yellow_on_cyan(text); end
  def bright_yellow_on_green(text); end
  def bright_yellow_on_magenta(text); end
  def bright_yellow_on_purple(text); end
  def bright_yellow_on_red(text); end
  def bright_yellow_on_white(text); end
  def bright_yellow_on_yellow(text); end
  def cyan(text); end
  def cyan_on_black(text); end
  def cyan_on_blue(text); end
  def cyan_on_cyan(text); end
  def cyan_on_green(text); end
  def cyan_on_magenta(text); end
  def cyan_on_purple(text); end
  def cyan_on_red(text); end
  def cyan_on_white(text); end
  def cyan_on_yellow(text); end
  def default(text); end
  def green(text); end
  def green_on_black(text); end
  def green_on_blue(text); end
  def green_on_cyan(text); end
  def green_on_green(text); end
  def green_on_magenta(text); end
  def green_on_purple(text); end
  def green_on_red(text); end
  def green_on_white(text); end
  def green_on_yellow(text); end
  def indent(text, chars); end
  def magenta(text); end
  def magenta_on_black(text); end
  def magenta_on_blue(text); end
  def magenta_on_cyan(text); end
  def magenta_on_green(text); end
  def magenta_on_magenta(text); end
  def magenta_on_purple(text); end
  def magenta_on_red(text); end
  def magenta_on_white(text); end
  def magenta_on_yellow(text); end
  def no_color; end
  def no_pager; end
  def purple(text); end
  def purple_on_black(text); end
  def purple_on_blue(text); end
  def purple_on_cyan(text); end
  def purple_on_green(text); end
  def purple_on_magenta(text); end
  def purple_on_purple(text); end
  def purple_on_red(text); end
  def purple_on_white(text); end
  def purple_on_yellow(text); end
  def red(text); end
  def red_on_black(text); end
  def red_on_blue(text); end
  def red_on_cyan(text); end
  def red_on_green(text); end
  def red_on_magenta(text); end
  def red_on_purple(text); end
  def red_on_red(text); end
  def red_on_white(text); end
  def red_on_yellow(text); end
  def strip_color(text); end
  def white(text); end
  def white_on_black(text); end
  def white_on_blue(text); end
  def white_on_cyan(text); end
  def white_on_green(text); end
  def white_on_magenta(text); end
  def white_on_purple(text); end
  def white_on_red(text); end
  def white_on_white(text); end
  def white_on_yellow(text); end
  def with_line_numbers(text, offset, color = _); end
  def yellow(text); end
  def yellow_on_black(text); end
  def yellow_on_blue(text); end
  def yellow_on_cyan(text); end
  def yellow_on_green(text); end
  def yellow_on_magenta(text); end
  def yellow_on_purple(text); end
  def yellow_on_red(text); end
  def yellow_on_white(text); end
  def yellow_on_yellow(text); end
end

Pry::Helpers::Text::COLORS = T.let(T.unsafe(nil), Hash)

class Pry::History
  def initialize(options = _); end

  def <<(line); end
  def clear; end
  def filter(history); end
  def history_line_count; end
  def load; end
  def loader; end
  def loader=(_); end
  def original_lines; end
  def push(line); end
  def saver; end
  def saver=(_); end
  def session_line_count; end
  def to_a; end

  private

  def history_file; end
  def history_file_path; end
  def invalid_readline_line?(line); end
  def read_from_file; end
  def save_to_file(line); end
  def should_ignore?(line); end

  def self.default_file; end
end

class Pry::Hooks
  def initialize; end

  def add_hook(event_name, hook_name, callable = _, &block); end
  def clear_event_hooks(event_name); end
  def delete_hook(event_name, hook_name); end
  def errors; end
  def exec_hook(event_name, *args, &block); end
  def get_hook(event_name, hook_name); end
  def get_hooks(event_name); end
  def hook_count(event_name); end
  def hook_exists?(event_name, hook_name); end
  def merge(other); end
  def merge!(other); end

  protected

  def hooks; end

  private

  def initialize_copy(_orig); end

  def self.default; end
end

class Pry::Indent
  include(::Pry::Helpers::BaseHelpers)

  def initialize(pry_instance = _); end

  def correct_indentation(prompt, code, overhang = _); end
  def current_prefix; end
  def end_of_statement?(last_token, last_kind); end
  def in_string?; end
  def indent(input); end
  def indent_level; end
  def indentation_delta(tokens); end
  def module_nesting; end
  def open_delimiters; end
  def open_delimiters_line; end
  def reset; end
  def stack; end
  def tokenize(string); end
  def track_delimiter(token); end
  def track_module_nesting(token, kind); end
  def track_module_nesting_end(token, kind = _); end

  def self.indent(str); end
  def self.nesting_at(str, line_number); end
end

Pry::Indent::IGNORE_TOKENS = T.let(T.unsafe(nil), Array)

Pry::Indent::MIDWAY_TOKENS = T.let(T.unsafe(nil), Array)

Pry::Indent::OPEN_TOKENS = T.let(T.unsafe(nil), Hash)

Pry::Indent::OPTIONAL_DO_TOKENS = T.let(T.unsafe(nil), Array)

Pry::Indent::SINGLELINE_TOKENS = T.let(T.unsafe(nil), Array)

Pry::Indent::SPACES = T.let(T.unsafe(nil), String)

Pry::Indent::STATEMENT_END_TOKENS = T.let(T.unsafe(nil), Array)

class Pry::Indent::UnparseableNestingError < ::StandardError
end

class Pry::InputCompleter
  def initialize(input, pry = _); end

  def build_path(input); end
  def call(str, options = _); end
  def ignored_modules; end
  def select_message(path, receiver, message, candidates); end
end

Pry::InputCompleter::ARRAY_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::CONSTANT_OR_METHOD_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::CONSTANT_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::GLOBALVARIABLE_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::HEX_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::NUMERIC_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::PROC_OR_HASH_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::REGEX_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::RESERVED_WORDS = T.let(T.unsafe(nil), Array)

Pry::InputCompleter::SYMBOL_METHOD_CALL_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::SYMBOL_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::TOPLEVEL_LOOKUP_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::VARIABLE_REGEXP = T.let(T.unsafe(nil), Regexp)

Pry::InputCompleter::WORD_ESCAPE_STR = T.let(T.unsafe(nil), String)

class Pry::InputLock
  def initialize; end

  def __with_ownership; end
  def enter_interruptible_region; end
  def interruptible_region; end
  def leave_interruptible_region; end
  def with_ownership(&block); end

  def self.for(input); end
  def self.global_lock; end
  def self.global_lock=(_); end
  def self.input_locks; end
  def self.input_locks=(_); end
end

class Pry::InputLock::Interrupt < ::Exception
end

class Pry::Inspector
end

Pry::Inspector::MAP = T.let(T.unsafe(nil), Hash)

Pry::LOCAL_RC_FILE = T.let(T.unsafe(nil), String)

class Pry::LastException < ::BasicObject
  def initialize(exception); end

  def bt_index; end
  def bt_index=(_); end
  def bt_source_location_for(index); end
  def file; end
  def inc_bt_index; end
  def line; end
  def method_missing(name, *args, &block); end
  def wrapped_exception; end

  private

  def respond_to_missing?(name, include_all = _); end
end

class Pry::Method
  include(::Pry::Helpers::BaseHelpers)
  include(::Pry::Helpers::DocumentationHelpers)
  include(::Pry::CodeObject::Helpers)
  extend(::Pry::Helpers::BaseHelpers)
  extend(::Forwardable)
  extend(::Pry::Forwardable)

  def initialize(method, known_info = _); end

  def ==(other); end
  def alias?; end
  def aliases; end
  def bound_method?; end
  def comment; end
  def doc; end
  def dynamically_defined?; end
  def is_a?(klass); end
  def kind_of?(klass); end
  def method_missing(method_name, *args, &block); end
  def name; end
  def name_with_owner; end
  def original_name; end
  def owner(*args, &block); end
  def parameters(*args, &block); end
  def pry_method?; end
  def receiver(*args, &block); end
  def redefine(source); end
  def respond_to?(method_name, include_all = _); end
  def signature; end
  def singleton_method?; end
  def source; end
  def source?; end
  def source_file; end
  def source_line; end
  def source_range; end
  def source_type; end
  def super(times = _); end
  def unbound_method?; end
  def undefined?; end
  def visibility; end
  def wrapped; end
  def wrapped_owner; end

  private

  def c_source; end
  def method_name_from_first_line(first_ln); end
  def pry_doc_info; end
  def respond_to_missing?(method_name, include_private = _); end
  def ruby_source; end
  def super_using_ancestors(ancestors, times = _); end

  def self.all_from_class(klass, include_super = _); end
  def self.all_from_obj(obj, include_super = _); end
  def self.from_binding(binding); end
  def self.from_class(klass, name, target = _); end
  def self.from_module(klass, name, target = _); end
  def self.from_obj(obj, name, target = _); end
  def self.from_str(name, target = _, options = _); end
  def self.instance_method_definition?(name, definition_line); end
  def self.instance_resolution_order(klass); end
  def self.lookup_method_via_binding(obj, method_name, method_type, target = _); end
  def self.method_definition?(name, definition_line); end
  def self.resolution_order(obj); end
  def self.singleton_class_of(obj); end
  def self.singleton_class_resolution_order(klass); end
  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::Method::Disowned < ::Pry::Method
  def initialize(receiver, method_name); end

  def method_missing(method_name, *args, &block); end
  def name; end
  def owner; end
  def receiver; end
  def source?; end
  def undefined?; end

  private

  def respond_to_missing?(method_name, include_private = _); end
end

class Pry::Method::Patcher
  def initialize(method); end

  def method; end
  def method=(_); end
  def patch_in_ram(source); end

  private

  def cache_key; end
  def definition_for_owner(line); end
  def redefine(source); end
  def with_method_transaction; end
  def wrap(source); end
  def wrap_for_nesting(source); end
  def wrap_for_owner(source); end

  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def initialize(method, target); end

  def find_method; end
  def lost_method?; end
  def method; end
  def method=(_); end
  def target; end
  def target=(_); end

  private

  def all_methods_for(obj); end
  def expanded_source_location(source_location); end
  def find_method_in_superclass; end
  def find_renamed_method; end
  def index_to_line_number(index); end
  def lines_for_file(file); end
  def normal_method?(method); end
  def pry_file?; end
  def renamed_method_source_location; end
  def skip_superclass_search?; end
  def target_file; end
  def target_line; end
  def target_self; end
  def valid_file?(file); end

  def self.normal_method?(method, binding); end
  def self.weird_method?(method, binding); end
end

class Pry::MethodNotFound < ::Pry::CommandError
end

class Pry::NoCommandError < ::StandardError
  def initialize(match, owner); end
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve; end

  private

  def complete?(segment); end
  def handle_failure(context, err); end
end

Pry::ObjectPath::SPECIAL_TERMS = T.let(T.unsafe(nil), Array)

class Pry::ObsoleteError < ::StandardError
end

class Pry::Output
  def initialize(pry_instance); end

  def <<(*objs); end
  def decolorize_maybe(str); end
  def height; end
  def method_missing(method_name, *args, &block); end
  def print(*objs); end
  def pry_instance; end
  def puts(*objs); end
  def size; end
  def tty?; end
  def width; end
  def write(*objs); end

  private

  def actual_screen_size; end
  def ansicon_env_size; end
  def env_size; end
  def io_console_size; end
  def nonzero_column?(size); end
  def readline_size; end
  def respond_to_missing?(method_name, include_private = _); end
end

Pry::Output::DEFAULT_SIZE = T.let(T.unsafe(nil), Array)

class Pry::Pager
  def initialize(pry_instance); end

  def open; end
  def page(text); end
  def pry_instance; end

  private

  def best_available; end
  def enabled?; end
  def output; end
end

class Pry::Pager::NullPager
  def initialize(out); end

  def <<(str); end
  def close; end
  def print(str); end
  def puts(str); end
  def write(str); end

  private

  def height; end
  def width; end
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?; end
  def record(str); end
  def reset; end

  private

  def line_length(line); end
end

class Pry::Pager::SimplePager < ::Pry::Pager::NullPager
  def initialize(*_); end

  def write(str); end
end

class Pry::Pager::StopPaging < ::StandardError
end

class Pry::Pager::SystemPager < ::Pry::Pager::NullPager
  def initialize(*_); end

  def close; end
  def write(str); end

  private

  def invoked_pager?; end
  def pager; end
  def write_to_pager(text); end

  def self.available?; end
  def self.default_pager; end
end

class Pry::PluginManager
  def initialize; end

  def load_plugins; end
  def locate_plugins; end
  def plugins; end

  private

  def gem_list; end
  def plugin_located?(plugin); end
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end

  def method_missing(*_); end

  private

  def respond_to_missing?(*_); end
end

Pry::PluginManager::PRY_PLUGIN_PREFIX = T.let(T.unsafe(nil), Regexp)

class Pry::PluginManager::Plugin
  def initialize(name, gem_name, spec, enabled); end

  def activate!; end
  def active; end
  def active=(_); end
  def active?; end
  def disable!; end
  def enable!; end
  def enabled; end
  def enabled=(_); end
  def enabled?; end
  def gem_name; end
  def gem_name=(_); end
  def load_cli_options; end
  def name; end
  def name=(_); end
  def spec; end
  def spec=(_); end
  def supported?; end
end

class Pry::Prompt
  def initialize(name, description, prompt_procs); end

  def [](key); end
  def description; end
  def incomplete_proc; end
  def name; end
  def prompt_procs; end
  def wait_proc; end

  def self.[](name); end
  def self.add(name, description = _, separators = _); end
  def self.all; end
end

class Pry::REPL
  extend(::Forwardable)
  extend(::Pry::Forwardable)

  def initialize(pry, options = _); end

  def input(*args, &block); end
  def output(*args, &block); end
  def pry; end
  def pry=(_); end
  def start; end

  private

  def calculate_overhang(current_prompt, original_val, indented_val); end
  def coolline_available?; end
  def epilogue; end
  def handle_read_errors; end
  def input_readline(*args); end
  def piping?; end
  def prologue; end
  def read; end
  def read_line(current_prompt); end
  def readline_available?; end
  def repl; end
  def set_readline_output; end

  def self.start(options); end
end

class Pry::REPLFileLoader
  def initialize(file_name); end

  def define_additional_commands; end
  def interactive_mode(pry_instance); end
  def load; end
  def non_interactive_mode(pry_instance, content); end
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def initialize(is_command, retval = _); end

  def command?; end
  def retval; end
  def void_command?; end
end

class Pry::Ring
  def initialize(max_size); end

  def <<(value); end
  def [](index); end
  def clear; end
  def count; end
  def max_size; end
  def size; end
  def to_a; end

  private

  def transpose_buffer_tail; end
end

class Pry::Slop
  include(::Enumerable)

  def initialize(config = _, &block); end

  def [](key); end
  def add_callback(label, &block); end
  def banner(banner = _); end
  def banner=(banner); end
  def command(command, options = _, &block); end
  def config; end
  def description(desc = _); end
  def description=(desc); end
  def each(&block); end
  def fetch_command(command); end
  def fetch_option(key); end
  def get(key); end
  def help; end
  def missing; end
  def on(*objects, &block); end
  def opt(*objects, &block); end
  def option(*objects, &block); end
  def options; end
  def parse(items = _, &block); end
  def parse!(items = _, &block); end
  def present?(*keys); end
  def run(callable = _, &block); end
  def separator(text); end
  def strict?; end
  def to_h(include_commands = _); end
  def to_hash(include_commands = _); end
  def to_s; end

  private

  def autocreate(items, index); end
  def build_option(objects, &block); end
  def clean(object); end
  def commands_to_help; end
  def execute_multiple_switches(option, argument, index); end
  def execute_option(option, argument, index, item = _); end
  def extract_long_flag(objects, config); end
  def extract_option(flag); end
  def extract_short_flag(objects, config); end
  def method_missing(method, *args, &block); end
  def process_item(items, index, &block); end
  def respond_to_missing?(method_name, include_all = _); end

  def self.optspec(string, config = _); end
  def self.parse(items = _, config = _, &block); end
  def self.parse!(items = _, config = _, &block); end
end

class Pry::Slop::Commands
  include(::Enumerable)

  def initialize(config = _, &block); end

  def [](key); end
  def arguments; end
  def banner(banner = _); end
  def banner=(_); end
  def commands; end
  def config; end
  def default(config = _, &block); end
  def each(&block); end
  def get(key); end
  def global(config = _, &block); end
  def help; end
  def inspect; end
  def on(command, config = _, &block); end
  def parse(items = _); end
  def parse!(items = _); end
  def present?(key); end
  def to_hash; end
  def to_s; end

  private

  def execute_arguments!(items); end
  def execute_global_opts!(items); end
end

Pry::Slop::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Pry::Slop::Error < ::StandardError
end

class Pry::Slop::InvalidArgumentError < ::Pry::Slop::Error
end

class Pry::Slop::InvalidCommandError < ::Pry::Slop::Error
end

class Pry::Slop::InvalidOptionError < ::Pry::Slop::Error
end

class Pry::Slop::MissingArgumentError < ::Pry::Slop::Error
end

class Pry::Slop::MissingOptionError < ::Pry::Slop::Error
end

class Pry::Slop::Option
  def initialize(slop, short, long, description, config = _, &block); end

  def accepts_optional_argument?; end
  def argument?; end
  def argument_in_value; end
  def argument_in_value=(_); end
  def as?; end
  def autocreated?; end
  def call(*objects); end
  def callback?; end
  def config; end
  def count; end
  def count=(_); end
  def default?; end
  def delimiter?; end
  def description; end
  def expects_argument?; end
  def help; end
  def inspect; end
  def key; end
  def limit?; end
  def long; end
  def match?; end
  def optional?; end
  def optional_argument?; end
  def required?; end
  def short; end
  def tail?; end
  def to_s; end
  def types; end
  def value; end
  def value=(new_value); end

  private

  def value_to_float(value); end
  def value_to_integer(value); end
  def value_to_range(value); end
end

Pry::Slop::Option::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

Pry::Slop::VERSION = T.let(T.unsafe(nil), String)

class Pry::SyntaxHighlighter
  def self.highlight(code, language = _); end
  def self.keyword_token_color; end
  def self.overwrite_coderay_comment_token!; end
  def self.tokenize(code, language = _); end
end

module Pry::SystemCommandHandler
  def self.default(output, command, _pry_instance); end
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

Pry::VERSION = T.let(T.unsafe(nil), String)

module Pry::Warning
  def self.warn(message); end
end

class Pry::WrappedModule
  include(::Pry::Helpers::BaseHelpers)
  include(::Pry::CodeObject::Helpers)

  def initialize(mod); end

  def candidate(rank); end
  def candidates; end
  def class?; end
  def constants(inherit = _); end
  def doc; end
  def file; end
  def line; end
  def method_missing(method_name, *args, &block); end
  def method_prefix; end
  def module?; end
  def nonblank_name; end
  def number_of_candidates; end
  def singleton_class?; end
  def singleton_instance; end
  def source; end
  def source_file; end
  def source_line; end
  def source_location; end
  def super(times = _); end
  def wrapped; end
  def yard_doc; end
  def yard_docs?; end
  def yard_file; end
  def yard_line; end

  private

  def all_methods_for(mod); end
  def all_relevant_methods_for(mod); end
  def all_source_locations_by_popularity; end
  def lines_for_file(file); end
  def method_candidates; end
  def method_defined_by_forwardable_module?(method); end
  def nested_module?(parent, name); end
  def primary_candidate; end
  def respond_to_missing?(method_name, include_private = _); end

  def self.from_str(mod_name, target = _); end
end

class Pry::WrappedModule::Candidate
  include(::Pry::Helpers::DocumentationHelpers)
  include(::Pry::CodeObject::Helpers)
  extend(::Forwardable)
  extend(::Pry::Forwardable)

  def initialize(wrapper, rank); end

  def class?(*args, &block); end
  def doc; end
  def file; end
  def line; end
  def module?(*args, &block); end
  def nonblank_name(*args, &block); end
  def number_of_candidates(*args, &block); end
  def source; end
  def source_file; end
  def source_line; end
  def source_location; end
  def wrapped(*args, &block); end

  private

  def class_regexes; end
  def first_line_of_module_definition(file, line); end
  def first_method_source_location; end
  def last_method_source_location; end
  def lines_for_file(*a, &b); end
  def method_candidates(*a, &b); end
  def name(*a, &b); end
  def number_of_lines_in_first_chunk; end
  def yard_docs?(*a, &b); end
end
